Composite(合成)模式：
合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。
合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。

缺点：Composite最大的问题在于不容易限制组合中的组件。 

涉及到三个角色：
抽象构件（Component）角色：这是一个抽象角色，它给参与组合的对象规定一个接口。这个角色给出共有接口及其默认行为。 
树叶构件（Leaf）角色：代表参加组合的树叶对象。一个树叶对象没有下级子对象。 
树枝构件（Composite）角色：代表参加组合的有子对象的对象，并给出树枝构件对象的行为。

Composite模式的应用范例
我们应用Composite模式来实现文件系统的文件/目录结构：
IFile：File与Folder的共通接口界面。相当于Component。
Folder：目录。目录下面有子目录，文件。相当于Composite。
File：文件。存在于目录之中。相当于Leaf。
Client类：测试类或者说使用类。

Composite模式两种方式
透明式的合成模式 --> sheer
作为第一种选择，在Component里面声明所有的用来管理子类对象的方法，包括add（）、remove（），以及getChild（）方法。
这样做的好处是所有的构件类都有相同的接口。在客户端看来，树叶类对象与合成类对象的区别起码在接口层次上消失了，
客户端可以同等同的对待所有的对象。这就是透明形式的合成模式。
这个选择的缺点是不够安全，因为树叶类对象和合成类对象在本质上是有区别的。树叶类对象不可能有下一个层次的对象，
因此add（）、remove（）以及getChild（）方法没有意义，是在编译时期不会出错，而只会在运行时期才会出错。

安全式的合成模式 --> safe
第二种选择是在Composite类里面声明所有的用来管理子类对象的方法。这样的做法是安全的做法，
因为树叶类型的对象根本就没有管理子类对象的方法，因此，如果客户端对树叶类对象使用这些方法时，程序会在编译时期出错。
这个选择的缺点是不够透明，因为树叶类和合成类将具有不同的接口。
这两个形式各有优缺点，需要根据软件的具体情况做出取舍决定。
