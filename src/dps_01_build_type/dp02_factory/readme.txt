工厂模式属于类的创建模式，工厂模式专门负责将大量有共同接口的类实例化。
工厂模式可以动态决定将哪一个类实例化，而不必事先知道每次要实例化哪一个类。

1）简单工厂模式（Simple Factory） [违背开放封闭原则]
话说十年前，有一个暴发户，他家有三辆汽车――Benz奔驰、Bmw宝马、Audi奥迪，还雇了司机为他开车。
不过，暴发户坐车时总是怪怪的：上Benz车后跟司机说“开奔驰车！”，坐上Bmw后他说“开宝马车！”，
坐上Audi说“开奥迪车！”。你一定说：这人有病！直接说开车不就行了？！
而当把这个暴发户的行为放到我们程序设计中来时，会发现这是一个普遍存在的现象。
幸运的是，这种有病的现象在OO（面向对象）语言中可以避免了。

简单工厂模式又称静态工厂方法模式。重命名上就可以看出这个模式一定很简单。它存在的目的很简单：定义一个用于创建对象的接口。
简单工厂模式的组成：
a.具体工厂(Concrete Creator)角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。
b.抽象产品(Product)角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。
c.具体产品(Concrete Product)角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。
简单工厂模式中没有抽象工厂(Creator)角色

2）工厂方法模式（Factory Method）
工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。
正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活起来――
当有新的产品（即暴发户的汽车）产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，
那么就可以被客户使用，而不必去修改任何已有的代码。可以看出工厂角色的结构也是符合开闭原则的！
我们还是老规矩，使用一个完整的例子来看看工厂模式各个角色之间是如何来协调的。
话说暴发户生意越做越大，自己的爱车也越来越多。这可苦了那位司机师傅了，什么车它都要记得，
维护，都要经过他来使用！于是暴发户同情他说：看你跟我这么多年的份上，以后你不用这么辛苦了，
我给你分配几个人手，你只管管好他们就行了！于是，工厂方法模式的管理出现了。

工厂方法模式去掉了简单工厂模式中工厂方法的静态属性，使得它可以被子类继承。这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式里不同的工厂子类来分担。
工厂方法模式的组成：
a.抽象工厂(Creator)角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。
b.具体工厂(Concrete Creator)角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。
c.抽象产品(Product)角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。
d.具体产品(Concrete Product)角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。

3）抽象工厂模式（Abstract Factory）
可以说，抽象工厂模式和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、最具一般性的。
抽象工厂模式的用意为：给客户端提供一个接口，可以创建多个产品族中的产品对象
而且使用抽象工厂模式还要满足一下条件：
1.系统中有多个产品族，而系统一次只可能消费其中一族产品。
2.同属于同一个产品族的产品以其使用。
抽象工厂模式的组成和工厂方法的如出一辙。
